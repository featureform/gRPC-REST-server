// /*
//  *
//  * Copyright 2015 gRPC authors.
//  *
//  * Licensed under the Apache License, Version 2.0 (the "License");
//  * you may not use this file except in compliance with the License.
//  * You may obtain a copy of the License at
//  *
//  *     http://www.apache.org/licenses/LICENSE-2.0
//  *
//  * Unless required by applicable law or agreed to in writing, software
//  * distributed under the License is distributed on an "AS IS" BASIS,
//  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  * See the License for the specific language governing permissions and
//  * limitations under the License.
//  *
//  */

// // Package main implements a client for Greeter service.
// package main

// import (
// 	"context"
// 	"fmt"
// 	"io"
// 	"log"
// 	"time"

// 	pb "github.com/Sami1309/go-grpc-server/grpc"
// 	"google.golang.org/grpc"

// 	"bytes"
// 	"encoding/json"
// 	"fmt"
// 	"net/http"
// 	"net/http/httptest"
// 	"os"
// 	"testing"

// 	//remote packages

// 	//my packagess

// 	"go-crud-app/middleware"
// 	"go-crud-app/models"
// 	"go-crud-app/router"

// 	"github.com/stretchr/testify/assert"
// )

// const (
// 	address = "localhost:7462"
// 	name    = "hello"
// )

// func main() {
// 	// Set up a connection to the server.
// 	conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())
// 	fmt.Printf("Connection type %T\n", conn)
// 	if err != nil {
// 		log.Fatalf("did not connect: %v", err)
// 	}
// 	defer conn.Close()
// 	c := pb.NewEmbeddingHubClient(conn)
// 	fmt.Printf("Client type %T\n", c)

// 	var space_name string = "test_space"
// 	var space_dims uint32 = 3

// 	// if len(os.Args) > 1 {
// 	// 	name = os.Args[1]
// 	// }
// 	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
// 	defer cancel()
// 	// r, err := c.SayHello(ctx, &pb.HelloRequest{Name: "hello"})

// 	r, err := c.CreateSpace(ctx, &pb.CreateSpaceRequest{Name: space_name, Dims: space_dims})
// 	r, err = c.CreateSpace(ctx, &pb.CreateSpaceRequest{Name: "test_space 2", Dims: space_dims})
// 	r, err = c.CreateSpace(ctx, &pb.CreateSpaceRequest{Name: "test_space 3", Dims: space_dims})

// 	if err != nil {
// 		log.Fatalf("Error message: ( %v)", err)
// 	}
// 	log.Printf("Created space: %s", r.String())

// 	var test_key string = "test_key"
// 	test_embedding := make([]float32, 3)
// 	test_embedding[0] = 1.0
// 	test_embedding[1] = 2.0
// 	test_embedding[2] = 3.0

// 	setResponse, setResponseErr := c.Set(ctx, &pb.SetRequest{Key: test_key, Embedding: &pb.Embedding{Values: test_embedding}, Space: space_name})

// 	if setResponseErr != nil {
// 		log.Fatalf("Error message: ( %v)", setResponseErr)
// 	}

// 	log.Printf("Greeting: %s", setResponse.String())

// 	new_test_key := "test_key"
// 	new_space_name := "test_space"
// 	getResponse, getResponseErr := c.Get(ctx, &pb.GetRequest{Key: new_test_key, Space: new_space_name})
// 	if getResponseErr != nil {
// 		log.Fatalf("Error message: ( %v)", getResponseErr)
// 	}

// 	log.Printf("Greeting: %s", getResponse.GetEmbedding())

// 	//stream response test
// 	stream, getSpacesError := c.DownloadSpaces(ctx, &pb.DownloadSpacesRequest{})
// 	if getSpacesError != nil {
// 		log.Fatalf("Error message: ( %v)", getSpacesError)
// 	}

// 	done := make(chan bool)

// 	go func() {
// 		for {
// 			resp, err := stream.Recv()
// 			if err == io.EOF {
// 				done <- true //means stream is finished
// 				return
// 			}
// 			if err != nil {
// 				log.Fatalf("cannot receive %v", err)
// 			}
// 			log.Printf("Space received: %s", resp.String())
// 		}
// 	}()

// 	<-done //we will wait until all response is received
// 	log.Printf("finished")

// }
